<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avatar AI Indonesia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            color: #fff;
            overflow: hidden;
            -webkit-text-size-adjust: 100%;
            touch-action: manipulation;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #root {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 120px 20px 160px 20px;
        }
        
        .avatar {
            width: min(400px, 60vw);
            height: min(400px, 60vw);
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        #avatar3d {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .ui-overlay {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: row;
            gap: 15px;
            width: calc(100% - 40px);
            max-width: 500px;
            justify-content: center;
        }
        
        button {
            padding: 16px 32px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            min-height: 52px;
            min-width: 140px;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        button:active {
            transform: scale(0.98);
            background: #0056b3;
        }
        
        button:hover {
            background: #0056b3;
            box-shadow: 0 6px 16px rgba(0,123,255,0.4);
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }
        
        .language-selector {
            background: #28a745;
            min-width: 80px;
            font-size: 14px;
        }
        
        .language-selector:hover {
            background: #218838;
        }
        
        .chat-input {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            width: calc(100% - 40px);
            max-width: 600px;
        }
        
        input {
            flex: 1;
            padding: 18px 20px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            font-size: 18px;
            background: rgba(255,255,255,0.1);
            color: white;
            backdrop-filter: blur(10px);
            min-height: 56px;
        }
        
        input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        input:focus {
            outline: none;
            border-color: #007bff;
            background: rgba(255,255,255,0.15);
        }
        
        .send-btn {
            min-width: 80px;
            flex-shrink: 0;
        }
        
        .status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 20px;
            border-radius: 12px;
            min-width: 160px;
            font-size: 16px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }
        
        .response-display {
            position: fixed;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 20px 25px;
            border-radius: 16px;
            max-width: calc(100% - 40px);
            width: auto;
            max-width: 600px;
            display: none;
            font-size: 18px;
            line-height: 1.5;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        
        /* Mobile responsive styles remain the same */
        @media (max-width: 768px) {
            .ui-overlay {
                flex-direction: column;
                max-width: 300px;
                gap: 12px;
            }
            
            button {
                width: 100%;
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="avatar" id="avatar">
            <canvas id="avatar3d"></canvas>
        </div>
    </div>
    
    <div class="ui-overlay">
        <button id="languageBtn" class="language-selector">ðŸ‡®ðŸ‡© ID</button>
        <button id="startBtn">Mulai Chat</button>
        <button id="voiceBtn">ðŸŽ¤ Suara</button>
    </div>
    
    <div class="chat-input">
        <input type="text" id="messageInput" placeholder="Ketik pesan Anda..." />
        <button id="sendBtn">Kirim</button>
    </div>
    
    <div class="status" id="status">Siap</div>
    <div class="response-display" id="responseDisplay"></div>
    
    <script>
        const avatar = document.getElementById('avatar');
        const status = document.getElementById('status');
        const responseDisplay = document.getElementById('responseDisplay');
        const messageInput = document.getElementById('messageInput');
        const languageBtn = document.getElementById('languageBtn');
        const startBtn = document.getElementById('startBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const sendBtn = document.getElementById('sendBtn');
        
        let isActive = true;
        let isListening = false;
        let currentLanguage = 'id'; // Default to Indonesian
        
        // Language configuration
        const languages = {
            id: {
                flag: 'ðŸ‡®ðŸ‡©',
                code: 'ID',
                label: 'Indonesia',
                ui: {
                    startChat: 'Mulai Chat',
                    voice: 'ðŸŽ¤ Suara',
                    send: 'Kirim',
                    placeholder: 'Ketik pesan Anda...',
                    ready: 'Siap',
                    chatActive: 'Chat Aktif',
                    processing: 'Memproses...',
                    listening: 'Mendengarkan...',
                    speaking: 'Berbicara...',
                    generating: 'Membuat suara...',
                    error: 'Error - menggunakan fallback',
                    speechError: 'Error suara - coba ketik'
                },
                speech: {
                    lang: 'id-ID',
                    voiceKeywords: ['Fahima', 'Gadis', 'Arif']
                }
            },
            en: {
                flag: 'ðŸ‡ºðŸ‡¸',
                code: 'EN',
                label: 'English',
                ui: {
                    startChat: 'Start Chat',
                    voice: 'ðŸŽ¤ Voice',
                    send: 'Send',
                    placeholder: 'Type your message...',
                    ready: 'Ready',
                    chatActive: 'Chat Active',
                    processing: 'Processing...',
                    listening: 'Listening...',
                    speaking: 'Speaking...',
                    generating: 'Generating speech...',
                    error: 'Error - using fallback',
                    speechError: 'Speech error - try typing'
                },
                speech: {
                    lang: 'en-US',
                    voiceKeywords: ['Matthew', 'Joanna', 'Brian']
                }
            }
        };
        
        // Update UI language
        function updateUILanguage() {
            const lang = languages[currentLanguage];
            languageBtn.innerHTML = `${lang.flag} ${lang.code}`;
            startBtn.textContent = lang.ui.startChat;
            voiceBtn.innerHTML = lang.ui.voice;
            sendBtn.textContent = lang.ui.send;
            messageInput.placeholder = lang.ui.placeholder;
            status.textContent = lang.ui.ready;
            document.title = currentLanguage === 'id' ? 'Avatar AI Indonesia' : 'AI Avatar';
            document.documentElement.lang = currentLanguage;
        }
        
        // Toggle language
        languageBtn.addEventListener('click', () => {
            currentLanguage = currentLanguage === 'id' ? 'en' : 'id';
            updateUILanguage();
        });
        
        // Add Enter key support
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendBtn.click();
            }
        });
        
        // Focus on input field when page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                messageInput.focus();
                updateUILanguage();
            }, 500);
        });
        
        // 3D Avatar System (keeping existing 3D code...)
        let scene, camera, renderer, avatarModel, mixer, clock;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isModelLoaded = false;
        
        // Initialize 3D Avatar (same as before)
        function init3DAvatar() {
            const canvas = document.getElementById('avatar3d');
            const container = document.getElementById('avatar');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true, 
                antialias: true 
            });
            
            const rect = container.getBoundingClientRect();
            renderer.setSize(rect.width, rect.height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
            fillLight.position.set(-1, 0, 1);
            scene.add(fillLight);
            
            // Camera position
            camera.position.set(0, 3.0, 2.0);
            camera.lookAt(0, 3.0, 0);
            
            // Load 3D model
            const loader = new THREE.GLTFLoader();
            loader.load(
                'https://models.readyplayer.me/6864cd2efe9030c714ea760d.glb',
                function(gltf) {
                    avatarModel = gltf.scene;
                    avatarModel.scale.set(3.0, 3.0, 3.0);
                    avatarModel.position.set(0, -2.0, 0);
                    
                    avatarModel.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(avatarModel);
                    
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(avatarModel);
                        gltf.animations.forEach(clip => {
                            mixer.clipAction(clip);
                        });
                    }
                    
                    isModelLoaded = true;
                    findBones();
                },
                undefined,
                function(error) {
                    createFallbackAvatar();
                }
            );
            
            clock = new THREE.Clock();
            
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function createFallbackAvatar() {
            const geometry = new THREE.SphereGeometry(0.3, 32, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.8
            });
            avatarModel = new THREE.Mesh(geometry, material);
            avatarModel.position.set(0, 0, 0);
            scene.add(avatarModel);
            isModelLoaded = true;
        }
        
        function onMouseMove(event) {
            if (!isModelLoaded) return;
            
            const rect = avatar.getBoundingClientRect();
            mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            targetRotationY = mouseX * 0.3;
            targetRotationX = mouseY * 0.2;
        }
        
        function onWindowResize() {
            const container = document.getElementById('avatar');
            const rect = container.getBoundingClientRect();
            
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            renderer.setSize(rect.width, rect.height);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (isModelLoaded && avatarModel) {
                if (!isTalking) {
                    const time = clock.getElapsedTime();
                    avatarModel.position.y = -2.0 + Math.sin(time * 2) * 0.02;
                }
                
                if (mixer) {
                    mixer.update(clock.getDelta());
                }
            }
            
            renderer.render(scene, camera);
        }
        
        let isTalking = false;
        let talkingAnimation = null;
        let headBone = null;
        let jawBone = null;
        let faceMesh = null;
        let smileBlendShape = null;
        let mouthShapes = {};
        let currentAudio = null;
        let isPlaying = false;
        
        // Avatar animation functions (keeping existing code)
        function setAvatarState(state) {
            avatar.className = 'avatar';
            
            if (!isModelLoaded) return;
            
            if (!faceMesh) {
                findBones();
            }
            
            switch(state) {
                case 'active':
                    avatar.className = 'avatar active';
                    stopTalking();
                    setSmile(0.6);
                    break;
                case 'processing':
                    avatar.className = 'avatar processing';
                    stopTalking();
                    clearSmile();
                    break;
                case 'speaking':
                    avatar.className = 'avatar speaking';
                    startTalking();
                    clearSmile();
                    break;
                case 'listening':
                    avatar.className = 'avatar processing';
                    stopTalking();
                    setSmile(0.4);
                    break;
                case 'idle':
                    stopTalking();
                    setSmile(0.3); // Gentle idle smile
                    break;
                default:
                    stopTalking();
                    setSmile(0.3); // Default gentle smile
                    break;
            }
        }
        
        function findBones() {
            if (!avatarModel) return;
            
            avatarModel.traverse(function(child) {
                if (child.isBone || child.name) {
                    const name = child.name.toLowerCase();
                    if (name.includes('head') && !headBone) {
                        headBone = child;
                    }
                    if (name.includes('jaw') && !jawBone) {
                        jawBone = child;
                    }
                }
                
                if (child.isMesh && child.morphTargetDictionary) {
                    faceMesh = child;
                    const morphTargets = child.morphTargetDictionary;
                    
                    for (let target in morphTargets) {
                        const targetName = target.toLowerCase();
                        if (targetName.includes('smile') || targetName.includes('happy') || targetName.includes('joy')) {
                            smileBlendShape = { mesh: child, index: morphTargets[target] };
                            break;
                        }
                    }
                    
                    const hasMouthShapes = morphTargets.hasOwnProperty('mouthOpen') || 
                                         morphTargets.hasOwnProperty('mouthSmile') ||
                                         morphTargets.hasOwnProperty('viseme_sil') ||
                                         Object.keys(morphTargets).some(key => 
                                            key.toLowerCase().includes('mouth') || 
                                            key.toLowerCase().includes('viseme')
                                         );
                    
                    if (hasMouthShapes) {
                        const meshName = child.name || '';
                        const isEyeMesh = meshName.toLowerCase().includes('eye');
                        
                        if (!isEyeMesh) {
                            mouthShapes[child.uuid] = {
                                mesh: child,
                                morphTargets: morphTargets
                            };
                        }
                    }
                }
            });
        }
        
        function setSmile(intensity = 0.5) {
            if (smileBlendShape && smileBlendShape.mesh.morphTargetInfluences) {
                smileBlendShape.mesh.morphTargetInfluences[smileBlendShape.index] = Math.max(0, Math.min(1, intensity));
            }
        }
        
        function clearSmile() {
            if (smileBlendShape && smileBlendShape.mesh.morphTargetInfluences) {
                smileBlendShape.mesh.morphTargetInfluences[smileBlendShape.index] = 0;
            }
            
            Object.values(mouthShapes).forEach(shapeData => {
                const morphTargets = shapeData.morphTargets;
                const mesh = shapeData.mesh;
                
                if (morphTargets.hasOwnProperty('mouthSmile')) {
                    const smileIndex = morphTargets['mouthSmile'];
                    mesh.morphTargetInfluences[smileIndex] = 0.0;
                }
            });
        }
        
        function startTalking() {
            if (isTalking) return;
            isTalking = true;
            
            function talkingLoop() {
                if (!isTalking || !avatarModel) return;
                
                const time = performance.now() * 0.003;
                
                avatarModel.rotation.y = Math.sin(time) * 0.015;
                avatarModel.rotation.x = Math.sin(time * 0.8) * 0.01;
                avatarModel.rotation.z = Math.sin(time * 1.2) * 0.005;
                
                talkingAnimation = requestAnimationFrame(talkingLoop);
            }
            
            talkingLoop();
        }
        
        function stopTalking() {
            isTalking = false;
            
            if (talkingAnimation) {
                cancelAnimationFrame(talkingAnimation);
                talkingAnimation = null;
            }
            
            if (avatarModel) {
                avatarModel.rotation.x = 0;
                avatarModel.rotation.y = 0;
                avatarModel.rotation.z = 0;
            }
        }
        
        // Initialize 3D avatar when page loads
        window.addEventListener('load', init3DAvatar);
        
        // Initialize in ready mode
        window.addEventListener('load', () => {
            setTimeout(() => {
                const lang = languages[currentLanguage];
                status.textContent = lang.ui.ready;
                setAvatarState('idle');
            }, 1000);
        });
        
        // Start chat button
        startBtn.addEventListener('click', () => {
            isActive = true;
            const lang = languages[currentLanguage];
            status.textContent = lang.ui.chatActive;
            setAvatarState('active');
            
            setTimeout(() => {
                setAvatarState('idle');
            }, 2000);
        });
        
        // Send message with language support
        sendBtn.addEventListener('click', async () => {
            const message = messageInput.value.trim();
            const lang = languages[currentLanguage];
            
            if (!message) return;
            
            if (!isActive) {
                isActive = true;
                status.textContent = lang.ui.chatActive;
            }
            
            status.textContent = lang.ui.processing;
            setAvatarState('processing');
            messageInput.value = '';
            responseDisplay.style.display = 'none';
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        message,
                        language: currentLanguage
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const aiResponse = data.response;
                
                responseDisplay.textContent = aiResponse;
                responseDisplay.style.display = 'block';
                
                // Generate speech with language-appropriate voice
                try {
                    status.textContent = lang.ui.generating;
                    
                    const audioResponse = await fetch('/api/speak', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            text: aiResponse,
                            language: currentLanguage,
                            gender: 'male'
                        })
                    });
                    
                    if (audioResponse.ok) {
                        const audioData = await audioResponse.json();
                        
                        if (audioData.audio && audioData.visemes) {
                            status.textContent = lang.ui.speaking;
                            setAvatarState('speaking');
                            
                            await playAudioWithLipSync(audioData.audio, audioData.visemes);
                            
                            status.textContent = lang.ui.ready;
                            setAvatarState('idle');
                            
                            setTimeout(() => {
                                responseDisplay.style.display = 'none';
                            }, 3000);
                            
                        } else if (audioData.useBrowserTTS) {
                            status.textContent = lang.ui.speaking;
                            setAvatarState('speaking');
                            
                            await playBrowserTTS(audioData.text, currentLanguage);
                            
                            status.textContent = lang.ui.ready;
                            setAvatarState('idle');
                            
                            setTimeout(() => {
                                responseDisplay.style.display = 'none';
                            }, 3000);
                        } else {
                            fallbackToTextDisplay();
                        }
                    } else {
                        fallbackToTextDisplay();
                    }
                    
                } catch (ttsError) {
                    console.error('TTS error:', ttsError);
                    fallbackToTextDisplay();
                }
                
                function fallbackToTextDisplay() {
                    status.textContent = lang.ui.speaking;
                    setAvatarState('speaking');
                    
                    const speakingTime = Math.max(2000, aiResponse.length * 50);
                    setTimeout(() => {
                        status.textContent = lang.ui.ready;
                        setAvatarState('idle');
                        
                        setTimeout(() => {
                            responseDisplay.style.display = 'none';
                        }, 3000);
                    }, speakingTime);
                }
                
            } catch (error) {
                console.error('Chat error:', error);
                const lang = languages[currentLanguage];
                status.textContent = lang.ui.error;
                
                const fallbackResponses = currentLanguage === 'id' ? [
                    "Halo! Bagaimana saya bisa membantu Anda hari ini?",
                    "Itu menarik! Ceritakan lebih lanjut.",
                    "Saya mengerti apa yang Anda katakan.",
                    "Pertanyaan yang bagus! Biarkan saya memikirkannya.",
                    "Saya di sini untuk membantu apa pun yang Anda butuhkan."
                ] : [
                    "Hello! How can I help you today?",
                    "That's interesting! Tell me more.",
                    "I understand what you're saying.",
                    "Great question! Let me think about that.",
                    "I'm here to help with whatever you need."
                ];
                
                const response = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
                responseDisplay.textContent = response;
                responseDisplay.style.display = 'block';
                setAvatarState('speaking');
                
                setTimeout(() => {
                    status.textContent = lang.ui.ready;
                    setAvatarState('idle');
                    setTimeout(() => {
                        responseDisplay.style.display = 'none';
                    }, 3000);
                }, 2000);
            }
        });
        
        // Voice input with language support
        voiceBtn.addEventListener('click', () => {
            const lang = languages[currentLanguage];
            
            if (!isActive) {
                isActive = true;
                status.textContent = lang.ui.chatActive;
            }
            
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = lang.speech.lang;
                
                if (!isListening) {
                    recognition.start();
                    isListening = true;
                    voiceBtn.innerHTML = 'ðŸ”´ ' + (currentLanguage === 'id' ? 'Mendengarkan...' : 'Listening...');
                    status.textContent = lang.ui.listening;
                    setAvatarState('listening');
                }
                
                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    messageInput.value = transcript;
                    sendBtn.click();
                };
                
                recognition.onend = () => {
                    isListening = false;
                    voiceBtn.innerHTML = lang.ui.voice;
                    if (status.textContent === lang.ui.listening) {
                        status.textContent = lang.ui.ready;
                        setAvatarState('idle');
                    }
                };
                
                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    isListening = false;
                    voiceBtn.innerHTML = lang.ui.voice;
                    status.textContent = lang.ui.speechError;
                    setAvatarState('idle');
                };
            } else {
                const alertMsg = currentLanguage === 'id' ? 
                    'Pengenalan suara tidak didukung di browser ini. Coba Chrome atau Edge.' :
                    'Speech recognition not supported in this browser. Try Chrome or Edge.';
                alert(alertMsg);
            }
        });
        
        // Browser TTS with Indonesian support
        async function playBrowserTTS(text, language) {
            return new Promise((resolve, reject) => {
                if (!('speechSynthesis' in window)) {
                    reject(new Error('Speech synthesis not supported'));
                    return;
                }
                
                const utterance = new SpeechSynthesisUtterance(text);
                const lang = languages[language];
                
                // Set language-appropriate voice
                const voices = speechSynthesis.getVoices();
                let selectedVoice = null;
                
                if (language === 'id') {
                    // Look for Indonesian voices
                    selectedVoice = voices.find(voice => 
                        voice.lang.startsWith('id') ||
                        voice.name.toLowerCase().includes('indonesia') ||
                        lang.speech.voiceKeywords.some(keyword => 
                            voice.name.toLowerCase().includes(keyword.toLowerCase())
                        )
                    );
                } else {
                    // English voices
                    selectedVoice = voices.find(voice => 
                        lang.speech.voiceKeywords.some(keyword => 
                            voice.name.toLowerCase().includes(keyword.toLowerCase())
                        ) ||
                        (voice.lang.startsWith('en') && voice.gender === 'male')
                    );
                }
                
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
                
                utterance.lang = lang.speech.lang;
                utterance.rate = 0.85;
                utterance.pitch = language === 'id' ? 0.8 : 0.6; // Slightly higher pitch for Indonesian
                utterance.volume = 0.8;
                
                utterance.onend = () => {
                    resolve();
                };
                
                utterance.onerror = (error) => {
                    reject(error);
                };
                
                speechSynthesis.speak(utterance);
            });
        }
        
        // Audio playback with lip sync (keeping existing function)
        async function playAudioWithLipSync(audioDataUrl, visemes) {
            return new Promise((resolve, reject) => {
                currentAudio = new Audio(audioDataUrl);
                isPlaying = true;
                
                let visemeIndex = 0;
                let animationId = null;
                
                const animateLipSync = () => {
                    if (!isPlaying || !currentAudio) return;
                    
                    const elapsed = currentAudio.currentTime;
                    
                    let targetIndex = visemeIndex;
                    for (let i = 0; i < visemes.length; i++) {
                        if (visemes[i].time <= elapsed) {
                            targetIndex = i;
                        } else {
                            break;
                        }
                    }
                    
                    if (targetIndex !== visemeIndex) {
                        visemeIndex = targetIndex;
                        const currentViseme = visemes[visemeIndex];
                        setViseme(currentViseme.viseme);
                    }
                    
                    if (!currentAudio.paused && !currentAudio.ended) {
                        animationId = requestAnimationFrame(animateLipSync);
                    } else {
                        isPlaying = false;
                        setViseme('sil');
                        // Restore smile when audio ends
                        setTimeout(() => {
                            if (!isTalking) {
                                setSmile(0.3);
                            }
                        }, 100);
                    }
                };
                
                currentAudio.onplay = () => {
                    animationId = requestAnimationFrame(animateLipSync);
                };
                
                currentAudio.onended = () => {
                    isPlaying = false;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    setViseme('sil');
                    // Restore smile after a brief delay
                    setTimeout(() => {
                        if (!isTalking) {
                            setSmile(0.3);
                        }
                    }, 100);
                    resolve();
                };
                
                currentAudio.onerror = (error) => {
                    isPlaying = false;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    setViseme('sil');
                    reject(error);
                };
                
                currentAudio.play().catch(reject);
            });
        }
        
        // Viseme mapping (same as before)
        const visemeToMouthShape = {
            'sil': { open: 0.0, smile: 0.0 },
            'p': { open: 0.0, smile: 0.0 },
            'f': { open: 0.15, smile: 0.0 },
            't': { open: 0.3, smile: 0.0 },
            'S': { open: 0.2, smile: 0.0 },
            's': { open: 0.2, smile: 0.0 },
            'r': { open: 0.3, smile: 0.0 },
            'k': { open: 0.25, smile: 0.0 },
            'a': { open: 0.6, smile: 0.0 },
            'e': { open: 0.4, smile: 0.0 },
            'i': { open: 0.2, smile: 0.0 },
            'o': { open: 0.5, smile: 0.0 },
            'u': { open: 0.3, smile: 0.0 },
            '@': { open: 0.4, smile: 0.0 }
        };
        
        function setViseme(viseme, weight = 1.0) {
            if (!avatarModel) return;
            if (Object.keys(mouthShapes).length === 0) return;
            
            const mouthShape = visemeToMouthShape[viseme];
            if (mouthShape) {
                Object.values(mouthShapes).forEach(shapeData => {
                    const morphTargets = shapeData.morphTargets;
                    const mesh = shapeData.mesh;
                    
                    if (morphTargets.hasOwnProperty('mouthOpen')) {
                        const openIndex = morphTargets['mouthOpen'];
                        const openValue = Math.max(0, Math.min(1, mouthShape.open * weight));
                        mesh.morphTargetInfluences[openIndex] = openValue;
                    }
                    
                    // Only clear smile during active speech, not when setting 'sil' at end
                    if (morphTargets.hasOwnProperty('mouthSmile') && isTalking && viseme !== 'sil') {
                        const smileIndex = morphTargets['mouthSmile'];
                        mesh.morphTargetInfluences[smileIndex] = 0.0;
                    }
                });
            }
        }
    </script>
</body>
</html>